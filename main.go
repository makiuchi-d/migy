package main

import (
	"errors"
	"fmt"
	"os"
	"os/user"
	"strconv"

	"github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"github.com/makiuchi-d/migy/sqlfile"
	"github.com/makiuchi-d/testdb"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var cmd = &cobra.Command{
	Use:           "migy",
	Short:         "A standalone database migration helper for MySQL",
	Long:          "",
	SilenceErrors: true,
	SilenceUsage:  true,
	Version:       getVersion(),
}

const signature = "-- Generated by migy (https://github.com/makiuchi-d/migy)"

var (
	quit      bool
	targetDir string
	targetNum int
	overwrite bool
	dbHost    string
	dbPort    int
	dbUser    string
	dbPass    string
	dbDsn     string
)

func init() {
	cmd.PersistentFlags().BoolP("help", "", false, "help for this command") // disable shorthand
	cmd.PersistentFlags().StringVarP(&targetDir, "dir", "d", ".", "directory with migration files")
	cmd.PersistentFlags().BoolVarP(&quit, "quit", "q", false, "quit stdout")
}

// numValue parses integer flags as 10-based number (000010 => 10)
type numValue int

var _ pflag.Value = (*numValue)(nil)

func (n *numValue) Set(s string) error {
	v, err := strconv.ParseInt(s, 10, 64)
	*n = numValue(v)
	return err
}

func (n *numValue) Type() string { return "int" }

func (n *numValue) String() string { return strconv.Itoa(int(*n)) }

func addFlagNumber(cmd *cobra.Command) {
	targetNum = -1
	f := cmd.Flags().VarPF((*numValue)(&targetNum), "number", "n", "target migration number")
	f.DefValue = "latest"
}

func addFlagForce(cmd *cobra.Command) {
	cmd.Flags().BoolVarP(&overwrite, "force", "f", false, "override the output file if it exists")
}

func addFlagsForDB(cmd *cobra.Command) {
	cmd.Flags().StringVarP(&dbHost, "host", "h", "", "database host")
	cmd.Flags().IntVarP(&dbPort, "port", "P", 3306, "database port")
	cmd.Flags().StringVarP(&dbUser, "user", "u", "", "database user")
	cmd.Flags().StringVarP(&dbPass, "password", "p", "", "database password")
	cmd.Flags().StringVarP(&dbDsn, "dsn", "", "", "data source name (e.g. user:pass@tcp(host:port)/dbname)")
}

func main() {
	err := cmd.Execute()
	if err != nil {
		fmt.Fprintln(os.Stderr, "error:", err.Error())
		os.Exit(-1)
	}
}

func warning(msg string) {
	fmt.Fprintln(os.Stderr, "warning:", msg)
}

func info(a ...any) {
	if quit {
		return
	}
	fmt.Fprintln(os.Stdout, a...)
}

func openDB(args []string) (*sqlx.DB, error) {
	if dbHost != "" {
		return openDBHost(dbUser, dbPass, dbHost, dbPort, args)
	}
	if dbDsn != "" {
		return openDSN(dbDsn)
	}
	return nil, errors.New("--host or --dsn required")
}

func openDBorDumpfile(args []string) (*sqlx.DB, error) {
	if dbHost != "" {
		return openDBHost(dbUser, dbPass, dbHost, dbPort, args)
	}
	if dbDsn != "" {
		return openDSN(dbDsn)
	}
	if len(args) > 0 {
		return openDumpfile(args[0])
	}
	// cmd_status allows no-datasource operation
	return nil, nil
}

func openDBHost(usr, pass, host string, port int, args []string) (*sqlx.DB, error) {
	if len(args) < 1 {
		return nil, errors.New("db_name is required")
	}
	up := usr
	if up == "" {
		u, err := user.Current()
		if err != nil {
			return nil, err
		}
		up = u.Username
	}
	if pass != "" {
		up += ":" + pass
	}
	dsn := fmt.Sprintf("%s@tcp(%s:%d)/%s?parseTime=true", up, host, port, args[0])
	return sqlx.Open("mysql", dsn)
}

func openDSN(dsn string) (*sqlx.DB, error) {
	c, err := mysql.ParseDSN(dsn)
	if err != nil {
		return nil, err
	}
	c.ParseTime = true
	db, err := sqlx.Open("mysql", c.FormatDSN())
	return db, err
}

func openDumpfile(dumpfile string) (*sqlx.DB, error) {
	db := sqlx.NewDb(testdb.New("db"), "mysql")
	if err := sqlfile.Apply(db, dumpfile); err != nil {
		return nil, err
	}
	return db, nil
}
